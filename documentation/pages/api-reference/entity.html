<h1>Entity API Reference</h1>

<h2>Attributes</h2>

<p>
  All attributes defined on dataclass are directly accessible on every entities of
  this dataclass.
</p>

<pre><code class="language-javascript" prism>ds.Person.$find(8).$promise.then(function (event) {
  var entity = event.result;

  entity.name;
  entity.age;
  entity.contributions;
});</code></pre>

<h2>Framework methods</h2>

<h3>A note about returned values</h3>
<p>
  Many of the entity methods return an empty object or array, with a
  <code>$promise</code> object referencing the operation promise. When the
  promise resolves, the object is filled. So, you can make a direct binding in the scope,
  and the object will be properly populated when the asynchronous treatment ends.<br />
  We will see this in the examples.
</p>

<h3><code>$save()</code></h3>

<p>
  Save an entity on server, no matter if it is a new entity created by <code>$create()</code>
  method or an existing one that needs to be updated. <code>$save()</code> method returns a
  promise on <code>$promise</code> property.
</p>

<pre><code class="language-javascript" prism>//Create a new entity and save it on server
var entity = ds.Person.$create({
  firstname: 'John',
  lastname: 'Smith'
});
entity.$save().$promise.then(function () {
  //entity is now saved. You can access its ID attribute
  console.log('new Person saved with id ' + entity.ID);
});

//You can also save an entity retrieved by a $find(), a $query(), etc.
ds.Person.$find(8).$promise.then(function (event) {
  var entity = event.result;

  entity.firstname = 'Jane';
  entity.$save();
});</code></pre>

<h3><code>$remove()</code></h3>

<p>
  Remove an existing and saved entity from the server. Return a promise on
  <code>$promise</code> object.
</p>

<pre><code class="language-javascript" prism>ds.Person.$find(8).$promise.then(function (event) {
  var entity = event.result;

  entity.$remove().$promise.then(function () {
    console.log('Entity has beem removed');
  });
});</code></pre>

<h3><code>$fetch()</code></h3>
<p>
  Force a refresh of the entity. <code>$fetch</code> is mostly used to lazy-load
  related entity that has not been expanded while retrieving the entity that contains it.
</p>

<pre><code class="language-javascript" prism>ds.Person.$find(8).$promise.then(function (event) {

  //Here, person.company is defined, but it's a deferred entity, it's not loaded
  var person = event.result;

  person.company.$fetch().$promise.then(function (event) {
    //Here, person.company is loaded, we can work with its attributes
    $scope.employeeCompanyName = person.company.name;
  });
});</code></pre>

<h3><code>$recompute()</code></h3>

<p>
  Execute server-side logic by simulating a save of the entity. The entity will
  be modified the following way:
</p>

<ul>
  <li>Calculated attributes are filled</li>
  <li><code>init</code> event is triggered if <code>$recompute</code> is called on a new entity (eg. that has never been saved yet)</li>
  <li><code>clientrefresh</code> event is triggered</li>
</ul>

<p>
  The entity <strong>is not saved</strong>, and all server-side computation that
  occured <strong>won't be persisted</strong>.
</p>
<p>
  <code>$recompute()</code> method allows you to <em>preview</em> your entity as
  if it were saved.
</p>

<pre><code class="language-javascript" prism>//Considering a Person dataClass with a fullName calculated attribute that is the concatenation of firstName and lastName
var person = ds.Person.$create({
  firstName: 'John',
  lastName: 'Smith'
});

person.$recompute().$promise.then(function () {
  person.fullName; //John Smith
});</code></pre>

<h3><code>$toJSON()</code></h3>

<p>
  Return a string containing a JSON representation of the current entity.
</p>

<pre><code class="language-javascript" prism>ds.Person.$find(8).$promise.then(function (event) {
  var person = event.result;
  person.$toJSON(); //{"ID": 8, "firstname": "John", "lastname": "Smith"}
})</code></pre>

<h2>User defined methods</h2>

<p>
  Wakanda allows you to create your own methods attached to dataClass. Those methods
  can be applied on the dataClass, on an entity or on a collection of this dataClass.
</p>
<p>
  All entity user defined methods are available with the same name on the
  entity. They all return a <code>$promise</code> object containing
  a promise. When the promise is resolved, the returned value (if any) of the method
  is put on the <code>result</code> property of then event passed to the callback given to
  <code>then()</code> method.
</p>

<pre><code class="language-javascript" prism>ds.Person.$find(8).$promise.then(function (event) {
  var person = event.result;

  person.myEntityMethod().$promise.then(function (event) {
    var returnedValue = event.result;
  });
});</code></pre>

<p>
  If the server method returns an entity or a collection, you will get an
  Angular-Wakanda entity or collection, with thir methods like
  <code>$fetch</code> or <code>$save</code> on it.
</p>

<doc-pagination page="{{currentPage}}" subpage="{{currentSubPage}}"></doc-pagination>
